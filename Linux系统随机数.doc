1.随机数至少具备两个条件：

  1)数字序列在统计上是随机的;
  2)不能通过已知序列推算后面的序列.
  
2.伪随机数：
    计算机利用设计好的算法结合用户提供的种子产生的随机数序列通常是“伪随机数”（pseudo-random number），伪随机数就是我们平时经常使用的“随机数”。伪随机数可以满足一般应用的需求，但是在对于安全要求比较高的环境和领域中存在明显的缺点。
    
    1)伪随机数是周期性的，当它们足够多时，会重复数字序列;
    2)如果提供相同的算法和相同的种子值，将会得出完全一样的随机数序列;
    3)可以使用逆向工程，猜测算法与种子值，以便推算后面所有的随机数列.


3.真随机数：
  借助物理世界中事物的随机性产生的随机数
  

4.Linux随机数
  4-1)PRNG(Pseudo-Random Number Generator)
  Linux 内核采用熵来描述数据的随机性;
  内核维护了一个熵池用来收集来自设备驱动程序和其它来源的环境噪音;
  熵估算：为跟踪熵池中数据的随机性，内核在将数据加入池的时候将估算数据的随机性。熵估算值描述池中包含的随机数位数，其值越大表示池中数据的随机性越好。 
  内核中随机数发生器 PRNG 为一个字符设备 random。
  random 设备了提供了 2 个字符设备供用户态进程使用——/dev/random 和/dev/urandom：

    /dev/random 适用于对随机数质量要求比较高的请求，在熵池中数据不足时， 读取 dev/random 设备时会返回小于熵池噪声总数的随机字节。/dev/random 可生成高随机性的公钥或一次性密码本。若熵池空了，对/dev/random 的读操作将会被阻塞，直到收集到了足够的环境噪声为止。这样的设计使得/dev/random 是真正的随机数发生器，提供了最大可能的随机数据熵。
    /dev/urandom，非阻塞的随机数发生器，它会重复使用熵池中的数据以产生伪随机数据。这表示对/dev/urandom 的读取操作不会产生阻塞，但其输出的熵可能小于/dev/random 的。它可以作为生成较低强度密码的伪随机数生成器，对大多数应用来说，随机性是可以接受的。
    
    内核提供了一个接口供其他模块使用：void get_random_bytes(void *buf, int nbytes);
    
    

参考：http://www.ibm.com/developerworks/cn/linux/1404_caobb_kvmrandom/index.html
  
  
